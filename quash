#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <sys/stat.h>

#define MAX_COMMAND_LENGTH 100
#define MAX_ARGUMENTS 30

// Structure to store information about background jobs
struct Job
{
    pid_t pid;
    char command[MAX_COMMAND_LENGTH];
    int completed;
    int job_id; // Unique job ID
    struct Job *next;
    char status[20];
};

struct Job *jobs_list = NULL; // Initialize the list of background jobs
int next_job_id = 1;          // Initialize the next job ID

// Function to add a new background job to the list
void add_job(pid_t pid, char input[MAX_COMMAND_LENGTH])
{
    struct Job *new_job = (struct Job *)malloc(sizeof(struct Job));
    new_job->pid = pid;
    strncpy(new_job->command, input, sizeof(new_job->command));
    new_job->completed = 0;
    new_job->job_id = next_job_id++;
    strncpy(new_job->status, "Running", sizeof(new_job->status));
    printf("Background job started: [%i] %d %s\n", new_job->job_id, new_job->pid, new_job->command);
    new_job->next = jobs_list;

    jobs_list = new_job;
}

// Function to update and report the status of background jobs
void update_jobs_status()
{
    struct Job *job = jobs_list;
    while (job != NULL)
    {
        int status;
        pid_t result = waitpid(job->pid, &status, WNOHANG); // Check job status without blocking
        if (result == -1)
        {
            strncpy(job->status, "Terminated", sizeof(job->status));
        }
        else if (result == 0)
        {
            strncpy(job->status, "Running", sizeof(job->status));
        }
        else
        {
            // The job has completed
            job->completed = 1;
            if (strcmp(job->status, "Terminated") != 0)
            {
                strncpy(job->status, "Completed", sizeof(job->status));
            }
        }
        job = job->next;
    }

    // Clean up completed jobs
    struct Job *current = jobs_list;
    struct Job *prev = NULL;
    int status;

    while (current != NULL)
    {

        if (current->completed)
        {
            waitpid(current->pid, &status, WUNTRACED);
            if (WIFEXITED(status))
            {
                printf("Background job %s: [%i] %d %s\n", current->status, current->job_id, current->pid, current->command);
            }

            if (prev == NULL)
            {
                jobs_list = current->next;
            }
            else
            {
                prev->next = current->next;
            }
            free(current);
            current = prev ? prev->next : jobs_list;
        }
        else
        {
            prev = current;
            current = current->next;
        }
    }
}

// Function to handle built-in commands
int handle_builtin(char **args, int in_fd, int out_fd)
{
    

    if (strcmp(args[0], "echo") == 0)
    {
        for (int i = 1; args[i] != NULL; i++)
        {
            if (args[i][0] == '$')
            {
                // Check if the argument is an environment variable
                char *env_var_name = args[i] + 1; // Skip the '$' character
                char *env_var_value = getenv(env_var_name);
                if (env_var_value != NULL)
                {
                    printf("%s ", env_var_value);
                }
                else
                {
                    fprintf(stderr, "echo: Undefined environment variable: %s\n", env_var_name);
                }
            }
            else
            {
                printf("%s ", args[i]);
            }
        }
        printf("\n");
    }

    else if (strcmp(args[0], "export") == 0)
    {
        if (args[1] != NULL)
        {
            char *env_var = args[1];
            if (strchr(env_var, '=') != NULL)
            {
                char *var_name = strtok(env_var, "=");
                char *var_value = strtok(NULL, "=");

                setenv(var_name, var_value, 1); // Update the environment variable
            }
            else
            {
                fprintf(stderr, "export: invalid argument\n");
            }
        }
        else
        {
            fprintf(stderr, "export: missing argument\n");
        }
    }

    else if (strcmp(args[0], "cd") == 0)
    {
        if (args[1] == NULL)
        {
            fprintf(stderr, "cd: missing directory\n");
        }
        else if (chdir(args[1]) == 0)
        {
            char *new_pwd = getcwd(NULL, 0);
            if (new_pwd != NULL)
            {
                setenv("PWD", new_pwd, 1);
                free(new_pwd);
            }
            else
            {
                perror("getcwd");
            }
            if (!(strcmp(args[1], "..") == 0))
            {
                printf("%s\n", args[1]);
            }
        }
        else
        {
            perror("chdir");
        }
    }

    else if (strcmp(args[0], "pwd") == 0)
    {
        char cwd[1024];
        if (getcwd(cwd, sizeof(cwd)) != NULL)
        {
            printf("%s\n", cwd);
        }
        else
        {
            perror("getcwd");
        }
    }

    else if (strcmp(args[0], "jobs") == 0)
    {
        update_jobs_status();
        struct Job *job = jobs_list;
        struct Job *jobs[MAX_COMMAND_LENGTH];
        int start = 0;
        int index = 0;
        int total = 0;
        while (job != NULL)
        {
            if (!job->completed)
            {
                jobs[index++] = job;
            }
            job = job->next;
        }
        total = index;
        index--;

        while (start < index)
        {
            struct Job *tmp = jobs[start];
            jobs[start] = jobs[index];
            jobs[index] = tmp;
            start++;
            index--;
        }
        for (int i = 0; i < total; i++)
        {
            printf("[%d] %d %s\n", jobs[i]->job_id, jobs[i]->pid, jobs[i]->command);
        }
    }
    else if (strcmp(args[0], "kill") == 0)
    {

        long long int pid = strtoll(args[2], NULL, 0);
        int signum = atoi(args[1]);
        struct Job *job = jobs_list;

        while (job != NULL)
        {
            if (job->pid == pid)
            {
                strncpy(job->status, "Terminated", sizeof(job->status));
                break;
            }
            job = job->next;
        }

        if (kill(pid, signum) == -1)
        {
            perror("kill");
        }
        free(job);
        update_jobs_status();
    }
    else
    {
        return 0; // not a built-in command
    }
    return 1; // Command was a built-in command
}

// Function to expand environment variables in a string
char *expand_environment_variables(const char *input)
{
    size_t input_length = strlen(input);
    char *expanded = malloc(2 * input_length + 1); // Allocate more space to accommodate variable expansions
    if (expanded == NULL)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    char *output = expanded; // Pointer to the current position in the output buffer

    const char *token = input;

    while (*token)
    {
        if (*token == '$' && (token == input || token[-1] != '\\'))
        {
            const char *start = token + 1;
            const char *end = start;

            // Parse the variable name
            while (*end && ((*end >= 'a' && *end <= 'z') || (*end >= 'A' && *end <= 'Z') || (*end >= '0' && *end <= '9') || *end == '_'))
            {
                end++;
            }

            if (end > start)
            {
                size_t var_name_length = end - start;
                char var_name[var_name_length + 1];
                strncpy(var_name, start, var_name_length);
                var_name[var_name_length] = '\0';

                char *var_value = getenv(var_name);
                if (var_value != NULL)
                {
                    size_t var_value_length = strlen(var_value);
                    if (output - expanded + var_value_length >= 2 * input_length)
                    {
                        size_t current_size = output - expanded;
                        expanded = realloc(expanded, 2 * current_size + var_value_length + 1);
                        if (expanded == NULL)
                        {
                            perror("realloc");
                            exit(EXIT_FAILURE);
                        }
                        output = expanded + current_size;
                    }
                    strncpy(output, var_value, var_value_length);
                    output += var_value_length;
                    token = end;
                }
                else
                {
                    // If the environment variable doesn't exist, keep the original text
                    while (start < end)
                    {
                        *output = *start;
                        output++;
                        start++;
                    }
                }
            }
            else
            {
                // If there is no variable name, keep the original character
                *output = *token;
                output++;
                token++;
            }
        }
        else
        {
            *output = *token;
            output++;
            token++;
        }
    }

    *output = '\0'; // Null-terminate the expanded string

    return expanded;
}

// Function to execute a command with input and output redirection
void execute_command(char **args, int in_fd, int out_fd, int final, int background, int start, char raw_input[MAX_COMMAND_LENGTH])
{

    pid_t pid = fork();

    if (pid < 0)
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0)
    { // Child process
        if (!handle_builtin(args, in_fd, out_fd))
        
        {
        if (in_fd != 0)
        {

            if (dup2(in_fd, 0) == -1)
            {
                perror("dup2");
                exit(EXIT_FAILURE);
            }
            close(in_fd);
        }

        if (out_fd != 1)
        {
            if (dup2(out_fd, 1) == -1)
            {
                perror("dup2");
                exit(EXIT_FAILURE);
            }

            close(out_fd);
        }
            execvp(args[0], args);
            perror("execvp");
            exit(EXIT_FAILURE);
        }
        else
        {
            exit(0);
        }
    }
    else
    { // Parent process
        if (background == 0)
        {
            int status;
            waitpid(pid, &status, 0);
        }
        if (background == 1 && start == 1)
        {
            add_job(pid, raw_input);
        }

        if (in_fd != 0)
        {
            close(in_fd);
        }
        if (out_fd != 1)
        {
            close(out_fd);
        }
        // Free memory for expanded arguments
        for (int i = 0; args[i] != NULL; i++)
        {
            free(args[i]);
        }
    }
}

// Function to tokenize the user input, handling comments and quoted sections
void tokenize_input(char *input, char **args, int *arg_counts)
{
    char *used_input[MAX_COMMAND_LENGTH];
    strcpy(*used_input, input);
    char *token = strtok(*used_input, " ");
    int arg_count = 0;
    int in_quoted_section = 0;
    char *quoted_argument = NULL;

    while (token != NULL)
    {

        if (token[0] == '#')
        {
            // Comment encountered, terminate the current command
            break;
        }

        if (strchr(token, '\"') != NULL)
        {
            in_quoted_section = 1;
            quoted_argument = strdup(token + 1); // Start a new quoted argument
            // Check if the current token contains the opening quote
            if (strchr(token, '\"') != NULL)
            {
                in_quoted_section = 0;
                size_t len = strlen(quoted_argument);
                quoted_argument[len - 1] = '\0';
                args[arg_count++] = quoted_argument;
                quoted_argument = NULL; // Reset for the next quoted section
            }
            else
            {
                token = strtok(NULL, " "); // Continue reading tokens until the closing quote is found
                while (token != NULL)
                {
                    size_t len = strlen(quoted_argument);
                    quoted_argument = realloc(quoted_argument, len + strlen(token) + 1); // +1 for null terminator
                    if (quoted_argument == NULL)
                    {
                        perror("realloc");
                        exit(EXIT_FAILURE);
                    }
                    strcat(quoted_argument, " ");
                    strcat(quoted_argument, token);
                    if (strchr(token, '\"') != NULL)
                    {
                        break;
                    }
                    token = strtok(NULL, " ");
                }
                if (token != NULL && strchr(token, '\"') != NULL)
                {
                    in_quoted_section = 0;
                    size_t len = strlen(quoted_argument);
                    quoted_argument[len - 1] = '\0';
                    args[arg_count++] = quoted_argument;
                    quoted_argument = NULL; // Reset for the next quoted section
                }
            }
        }
        else if (strchr(token, '\'') != NULL)
        {
            in_quoted_section = 1;
            quoted_argument = strdup(token + 1); // Start a new quoted argument
            // Check if the current token contains the opening quote
            if (strchr(token, '\'') != NULL)
            {
                in_quoted_section = 0;
                size_t len = strlen(quoted_argument);
                quoted_argument[len - 1] = '\0';
                args[arg_count++] = quoted_argument;
                quoted_argument = NULL; // Reset for the next quoted section
            }
            else
            {
                token = strtok(NULL, " "); // Continue reading tokens until the closing quote is found
                while (token != NULL)
                {
                    size_t len = strlen(quoted_argument);
                    quoted_argument = realloc(quoted_argument, len + strlen(token) + 1); // +1 for null terminator
                    if (quoted_argument == NULL)
                    {
                        perror("realloc");
                        exit(EXIT_FAILURE);
                    }
                    strcat(quoted_argument, " ");
                    strcat(quoted_argument, token);
                    if (strchr(token, '\'') != NULL)
                    {
                        break;
                    }
                    token = strtok(NULL, " ");
                }
                if (token != NULL && strchr(token, '\'') != NULL)
                {
                    in_quoted_section = 0;
                    size_t len = strlen(quoted_argument);
                    quoted_argument[len - 1] = '\0';
                    args[arg_count++] = quoted_argument;
                    quoted_argument = NULL; // Reset for the next quoted section
                }
            }
        }

        else
        {
            args[arg_count++] = strdup(token);
        }

        token = strtok(NULL, " ");
    }
    args[arg_count] = NULL;
    *arg_counts = arg_count;
}

int main()
{
    char input[MAX_COMMAND_LENGTH];
    printf("Welcome...\n");

    while (1)
    {
        update_jobs_status();
        pid_t pid = getpid();
        printf("[QUASH]%d$ ", pid);
        fflush(stdout);

        // Read user input
        if (fgets(input, sizeof(input), stdin) == NULL)
        {
            perror("fgets");
            exit(EXIT_FAILURE);
        }

        // Remove the newline character at the end
        input[strcspn(input, "\n")] = '\0';

        if (input[0] == '\0')
        {
            continue;
        }

        // Tokenize the user input into arguments, handling comments and quoted sections
        char *args[MAX_ARGUMENTS];
        int arg_count = 0;
        int background = 0;

        tokenize_input(input, args, &arg_count);

        if (arg_count > 1)
        {
            if (strcmp(args[arg_count - 1], "&") == 0)
            {
                background = 1;
                args[arg_count - 1] = '\0';
                arg_count -= 1;
            }
        }
        int done = 0;

        if (arg_count == 0)
        {
            continue;
        }

        // Expand environment variables in the command arguments
        for (int i = 0; args[i] != NULL; i++)
        {
            char *expanded_arg = expand_environment_variables(args[i]);
            args[i] = expanded_arg;
        }

        if ((strcmp(args[0], "quit") == 0) || (strcmp(args[0], "exit") == 0))
        {
            if (args[1] != NULL)
            {
                printf("%s does not require additional arguments\n", args[0]);
                continue;
            }
            else
            {
                done = 1;
            }
        }

        if (done == 1)
        {
            break;
        }

        // Check for pipe symbols
        int pipe_positions[MAX_ARGUMENTS]; // To store positions of pipe symbols
        int num_pipes = 0;
        int redirected = 0;

        for (int i = 0; i < arg_count; i++)
        {
            if (strcmp(args[i], "|") == 0)
            {
                if (num_pipes < MAX_ARGUMENTS)
                {
                    pipe_positions[num_pipes] = i;
                    num_pipes++;
                }
                else
                {
                    fprintf(stderr, "Too many pipes in the command\n");
                    exit(EXIT_FAILURE);
                }
            }
        }

        if (num_pipes > 0)
        {
            redirected = 1;
            // Handle piped commands
            int pipes_fd[num_pipes][2];

            int command_start = 0;
            int command_end = 0;

            for (int i = 0; i <= num_pipes; i++)
            {
                if (i < num_pipes)
                {
                    command_end = pipe_positions[i];
                }
                else
                {
                    command_end = arg_count;
                }

                char *command_args[MAX_ARGUMENTS];
                int command_args_count = 0;

                for (int j = command_start; j < command_end; j++)
                {
                    command_args[command_args_count] = args[j];
                    command_args_count++;
                }

                command_args[command_args_count] = NULL;

                if (i < num_pipes)
                {
                    if (pipe(pipes_fd[i]) == -1)
                    {
                        perror("pipe");
                        exit(EXIT_FAILURE);
                    }
                }

                int redirect_in = 0;  // File descriptor for input redirection
                int redirect_out = 1; // File descriptor for output redirection

                for (int i = 0; i < command_args_count; i++)
                {
                    if (strcmp(command_args[i], ">") == 0)
                    {
                        if (args[i + 1] != NULL)
                        {
                            char *output_file = command_args[i + 1]; // Get the filename for output redirection
                            redirect_out = open(output_file, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
                            if (redirect_out == -1)
                            {
                                perror("open");
                                exit(EXIT_FAILURE);
                            }
                            // Terminate the command before redirection
                            command_args[i] = NULL;
                            command_args[i + 1] = NULL;
                            command_args_count--;
                            command_args_count--;
                            break;
                        }
                        else
                        {
                            fprintf(stderr, "Missing filename for output redirection\n");
                            break;
                        }
                    }
                    else if (strcmp(command_args[i], ">>") == 0)
                    {
                        if (command_args[i + 1] != NULL)
                        {
                            char *output_file = command_args[i + 1]; // Get the filename for output redirection
                            redirect_out = open(output_file, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
                            if (redirect_out == -1)
                            {
                                perror("open");
                                exit(EXIT_FAILURE);
                            }
                            // Terminate the command before redirection
                            command_args[i] = NULL;
                            command_args[i + 1] = NULL;
                            command_args_count--;
                            command_args_count--;
                            break;
                        }
                        else
                        {
                            fprintf(stderr, "Missing filename for output redirection\n");
                            break;
                        }
                    }
                    else if (strcmp(command_args[i], "<") == 0)
                    {
                        if (command_args[i + 1] != NULL)
                        {
                            redirect_in = open(command_args[i + 1], O_RDONLY);
                            if (redirect_in == -1)
                            {
                                perror("open");
                                exit(EXIT_FAILURE);
                            }
                            // Terminate the command before redirection
                            command_args[i] = NULL;
                            command_args[i + 1] = NULL;
                            command_args_count--;
                            command_args_count--;
                        }
                        else
                        {
                            fprintf(stderr, "Missing filename for input redirection\n");
                            break;
                        }
                    }
                }

                if (i == 0)
                {
                    // For the first command, set the input to stdin
                    if (!handle_builtin(args, redirect_in, pipes_fd[i][1]))
                    {
                        execute_command(command_args, redirect_in, pipes_fd[i][1], 0, background, 1, input);
                    }
                }
                else if (i == num_pipes)
                {
                    // For the last command, set the output to stdout
                    if (!handle_builtin(args, pipes_fd[i - 1][0], redirect_out))
                    {
                        execute_command(command_args, pipes_fd[i - 1][0], redirect_out, 1, background, 0, input);
                    }
                }
                else
                {
                    // For intermediate commands, set both input and output
                    if (!handle_builtin(args, pipes_fd[i - 1][0], pipes_fd[i][1]))
                    {
                        execute_command(command_args, pipes_fd[i - 1][0], pipes_fd[i][1], 0, background, 0, input);
                    }
                }
                if (redirect_in > 0)
                {
                    close(redirect_in);
                }
                if (redirect_out > 1)
                {
                    close(redirect_out);
                }
                command_start = command_end + 1;
            }
            for (size_t i = 0; i < num_pipes; i++)
            {
                // Close the pipe file descriptors
                close(pipes_fd[i][0]);
                close(pipes_fd[i][1]);
            }
        }
        else
        {
            // If there are no pipes, execute the command as usual
            int redirect_in = 0;  // File descriptor for input redirection
            int redirect_out = 1; // File descriptor for output redirection

            for (int i = 0; i < arg_count; i++)
            {
                if (strcmp(args[i], ">") == 0)
                {
                    if (args[i + 1] != NULL)
                    {
                        char *output_file = args[i + 1]; // Get the filename for output redirection
                        redirect_out = open(output_file, O_WRONLY | O_TRUNC | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
                        if (redirect_out == -1)
                        {
                            perror("open");
                            exit(EXIT_FAILURE);
                        }
                        // Terminate the command before redirection
                        args[i] = NULL;
                        args[i + 1] = NULL;
                        break;
                    }
                    else
                    {
                        fprintf(stderr, "Missing filename for output redirection\n");
                        break;
                    }
                }
                else if (strcmp(args[i], ">>") == 0)
                {
                    if (args[i + 1] != NULL)
                    {
                        char *output_file = args[i + 1]; // Get the filename for output redirection
                        redirect_out = open(output_file, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
                        if (redirect_out == -1)
                        {
                            perror("open");
                            exit(EXIT_FAILURE);
                        }
                        // Terminate the command before redirection
                        args[i] = NULL;
                        args[i + 1] = NULL;
                        break;
                    }
                    else
                    {
                        fprintf(stderr, "Missing filename for output redirection\n");
                        break;
                    }
                }
                else if (strcmp(args[i], "<") == 0)
                {
                    if (args[i + 1] != NULL)
                    {
                        redirect_in = open(args[i + 1], O_RDONLY);
                        if (redirect_in == -1)
                        {
                            perror("open");
                            exit(EXIT_FAILURE);
                        }
                        // Terminate the command before redirection
                        args[i] = NULL;
                    }
                    else
                    {
                        fprintf(stderr, "Missing filename for input redirection\n");
                        break;
                    }
                }
            }

            // Execute the command
            if (redirected == 0)
            {
                if (!handle_builtin(args, redirect_in, redirect_out))
                {
                    execute_command(args, redirect_in, redirect_out, 1, background, 1, input);
                }
            }

            if (redirect_in > 0)
            {
                close(redirect_in);
            }
            if (redirect_out > 1)
            {
                close(redirect_out);
            }
            update_jobs_status();
        }
    }

    struct Job *job = jobs_list;
    while (job != NULL)
    {
        struct Job *next = job->next;
        free(job);
        job = next;
    }

    return 0;
}